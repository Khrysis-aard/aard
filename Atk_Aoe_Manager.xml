<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Saturday, December 21, 2024, 12:21 AM -->
<!-- MuClient version 5.07-pre -->

<!-- Plugin "Atk_Aoe_Manager" generated by Plugin Wizard -->

<muclient>
<plugin
   name="Atk_Aoe_Manager"
   author="Khrysis"
   id="689c1286fe55ac130d90458c"
   language="Lua"
   purpose="Manage Your Atk and Aoe spells"
   save_state="y"
   date_written="2024-12-21 00:10:03"
   requires="5.07"
   version="1.30"
   >
<description trim="y">
<![CDATA[
This plugin allows you to add and remove attack and AoE spells using the 'aam add' and 'aam rem' aliases.
These go on a list that it will keep updated as you aquire the spells on it or as you get higher level ones on the list.
This keeps your atk and aoe variables automatically updated based on what you want.
You can also list the current attack and AoE spells with 'aam list patk', 'aam list aoe', or 'aam list all'.
]]>
</description>

</plugin>

<!--  Triggers  -->

<triggers>
<!-- Combined Trigger for Expert-level AoE and Attack spells -->
<trigger
   enabled="y"
   group="set spell on tier or R1"
   match="^You are now an expert in (.*)\.$"
   regexp="y"
   expand_variables="y"
   send_to="12"
   sequence="100"
  >
    <send>
      -- Get the spell/skill name
      local spell = "%1"
      local found = false
      local spellCategory = nil  -- Track the category (Patk, Aoe, or Skill)

      -- Check Patk first
      for _, v in ipairs(Patk) do
        if string.lower(v) == string.lower(spell) then
          spellCategory = "atk"
          found = true
          break
        end
      end

      -- If not found in Patk, check Aoe
      if not found then
        for _, v in ipairs(Aoe) do
          if string.lower(v) == string.lower(spell) then
            spellCategory = "aoe"
            found = true
            break
          end
        end
      end

      -- If not found in Aoe, check Skills
      if not found then
        for _, v in ipairs(Skills) do
          if string.lower(v) == string.lower(spell) then
            spellCategory = "skill"
            found = true
            break
          end
        end
      end

      -- If the spell/skill is found, update the appropriate variable
      if found then
        if spellCategory == "atk" then
          local currentSpell = GetVariable("atkspell")
          if string.lower(currentSpell) ~= string.lower(spell) then
            SetVariable("atkspell", spell)
            Note("Attack spell is now: " .. spell)
          end
        elseif spellCategory == "aoe" then
          local currentSpell = GetVariable("aoespell")
          if string.lower(currentSpell) ~= string.lower(spell) then
            SetVariable("aoespell", spell)
            Note("AoE spell is now: " .. spell)
          end
        elseif spellCategory == "skill" then
          local currentSkill = GetVariable("skill")
          if string.lower(currentSkill) ~= string.lower(spell) then
            SetVariable("skill", spell)
            Note("Skill is now: " .. spell)
          end
        end
      end
    </send>
  </trigger>

<!-- Combined Trigger for 95% match AoE and Attack spells -->
<trigger
   enabled="y"
   group="set spell (95%)"
   match="^(Spell|Skill) (.*)\. \((95|85)\%\)$"
   regexp="y"
   expand_variables="y"
   send_to="12"
   sequence="100"
  >
    <send>
      -- Get the spell/skill name
      local spell = "%2"
      local found = false
      local spellCategory = nil  -- Track the category (Patk, Aoe, or Skill)

      -- Check Patk first
      for _, v in ipairs(Patk) do
        if string.lower(v) == string.lower(spell) then
          spellCategory = "atk"
          found = true
          break
        end
      end

      -- If not found in Patk, check Aoe
      if not found then
        for _, v in ipairs(Aoe) do
          if string.lower(v) == string.lower(spell) then
            spellCategory = "aoe"
            found = true
            break
          end
        end
      end

      -- If not found in Aoe, check Skills
      if not found then
        for _, v in ipairs(Skills) do
          if string.lower(v) == string.lower(spell) then
            spellCategory = "skill"
            found = true
            break
          end
        end
      end

      -- If the spell/skill is found, update the appropriate variable
      if found then
        if spellCategory == "atk" then
          local currentSpell = GetVariable("atkspell")
          if string.lower(currentSpell) ~= string.lower(spell) then
            SetVariable("atkspell", spell)
            Note("Attack spell is now: " .. spell)
          end
        elseif spellCategory == "aoe" then
          local currentSpell = GetVariable("aoespell")
          if string.lower(currentSpell) ~= string.lower(spell) then
            SetVariable("aoespell", spell)
            Note("AoE spell is now: " .. spell)
          end
        elseif spellCategory == "skill" then
          local currentSkill = GetVariable("skill")
          if string.lower(currentSkill) ~= string.lower(spell) then
            SetVariable("skill", spell)
            Note("Skill is now: " .. spell)
          end
        end
      end
    </send>
  </trigger>



</triggers>

<!-- Aliases -->
<aliases>
   <alias 
  match="aam update check" 
  enabled="y" 
  script="update_check_alias" 
  sequence="99"
  >
  </alias>
  
  <alias 
  match="aam update install" 
  enabled="y" 
  script="update_install_alias" 
  sequence="99"
  >
  </alias>
  <!-- Add primary attack spell -->
  <alias
   match="aam add patk (.*)"
   enabled="y"
   group="attack"
   send_to="12"
   sequence="100"
   expand_variables="y"
   regexp="y"
  >
    <send>local spell = "%1"
      -- Add spell to the Patk table (case-insensitive check for existing spell)
      local found = false
      for _, v in ipairs(Patk) do
        if string.lower(v) == string.lower(spell) then
          found = true
          break
        end
      end
      if not found then
        table.insert(Patk, spell)
        Note("Added primary attack spell: " .. spell)
      else
        Note("Spell already exists in the primary attack spells list.")
      end
    </send>
  </alias>

  <!-- Remove primary attack spell -->
  <alias
   match="aam rem patk (.*)"
   enabled="y"
   group="attack"
   send_to="12"
   sequence="100"
   expand_variables="y"
   regexp="y"
  >
    <send>
      local spell = "%1"
      -- Find the index of the spell in the Patk table (case-insensitive)
      local index = nil
      for i, v in ipairs(Patk) do
        if string.lower(v) == string.lower(spell) then
          index = i
          break
        end
      end
      -- Remove spell if found
      if index then
        table.remove(Patk, index)
        Note("Removed primary attack spell: " .. spell)
      else
        Note("Spell not found in the primary attack spells.")
      end
    </send>
  </alias>

  <!-- Add AoE spell -->
  <alias
   match="aam add aoe (.*)"
   enabled="y"
   group="attack"
   send_to="12"
   sequence="100"
   expand_variables="y"
   regexp="y"
  >
    <send>local spell = "%1"
      -- Add spell to the Aoe table (case-insensitive check for existing spell)
      local found = false
      for _, v in ipairs(Aoe) do
        if string.lower(v) == string.lower(spell) then
          found = true
          break
        end
      end
      if not found then
        table.insert(Aoe, spell)
        Note("Added AoE spell: " .. spell)
      else
        Note("Spell already exists in the AoE spells list.")
      end
    </send>
  </alias>

  <!-- Remove AoE spell -->
  <alias
   match="aam rem aoe (.*)"
   enabled="y"
   group="attack"
   send_to="12"
   sequence="100"
   expand_variables="y"
   regexp="y"
  >
    <send>
      local spell = "%1"
      -- Find the index of the spell in the Aoe table (case-insensitive)
      local index = nil
      for i, v in ipairs(Aoe) do
        if string.lower(v) == string.lower(spell) then
          index = i
          break
        end
      end
      -- Remove spell if found
      if index then
        table.remove(Aoe, index)
        Note("Removed AoE spell: " .. spell)
      else
        Note("Spell not found in the AoE spells.")
      end
    </send>
  </alias>

  <!-- List Primary Attack Spells, AoE Spells, Skills or All -->
  <alias
   match="aam list (all|patk|aoe|skill|shortsyntax)"
   enabled="y"
   group="attack"
   send_to="12"
   sequence="100"
   expand_variables="y"
   regexp="y"
  >
    <send>
      local listType = "%1"
      
      if listType == "patk" then
        if #Patk == 0 then
          Note("No primary attack spells available.")
        else
          Note("Primary Attack Spells: " .. table.concat(Patk, ", "))
        end
      elseif listType == "aoe" then
        if #Aoe == 0 then
          Note("No AoE spells available.")
        else
          Note("AoE Spells: " .. table.concat(Aoe, ", "))
        end
      elseif listType == "skill" then
        if #Skills == 0 then
          Note("No skills available.")
        else
          Note("Skills: " .. table.concat(Skills, ", "))
        end
	  elseif listType == "shortsyntax" then
      if next(SkillShortSyntax) == nil then  -- Check if table is empty
        Note("No short syntax defined for any skills.")
      else
        Note("Short syntax you have:")
        for skill, syntax in pairs(SkillShortSyntax) do
          Note(skill .. " -> " .. syntax)
        end
      end
      else
        -- For "all", show Patk, Aoe, and Skills
        if #Patk == 0 and #Aoe == 0 and #Skills == 0 then
          Note("No spells or skills available.")
        else
          if #Patk > 0 then
            Note("Primary Attack Spells: " .. table.concat(Patk, ", "))
          else
            Note("No primary attack spells available.")
          end
          if #Aoe > 0 then
            Note("AoE Spells: " .. table.concat(Aoe, ", "))
          else
            Note("No AoE spells available.")
          end
          if #Skills > 0 then
            Note("Skills: " .. table.concat(Skills, ", "))
          else
            Note("No skills available.")
          end
        end
      end
    </send>
  </alias>


  <!-- Show Help -->
  <alias
   script="OnHelp"
   match="aam help"
   enabled="y"
  >
  </alias>

  <!-- Cast Attack Spell -->
  <alias
   match="aam atk"
   enabled="y"
   group="attack"
   send_to="12"
   sequence="100"
  >
    <send>-- Get variable
	atkspell = GetVariable("atkspell")
      -- Cast the attack spell
      if atkspell then
        Send("c '".. atkspell .."'")
        Note("Casting attack spell: " .. atkspell)
      else
        Note("No primary attack spell selected.")
      end
    </send>
  </alias>
   <alias
   match="aam atk *"
   enabled="y"
   group="attack"
   send_to="12"
   sequence="100"
  >
    <send>-- Get variable
	atkspell = GetVariable("atkspell")
	local mobname = "%1"
      -- Cast the attack spell
      if atkspell then
        Send("c '".. atkspell .."' ".. mobname)
        Note("Casting attack spell: " .. atkspell)
      else
        Note("No primary attack spell selected.")
      end
    </send>
  </alias>

  <!-- Cast AoE Spell -->
  <alias
   match="aam aoe"
   enabled="y"
   group="attack"
   send_to="12"
   sequence="100"
  >
    <send>-- Get variable
	aoespell = GetVariable("aoespell")
      -- Cast the AoE spell
      if aoespell then
        Send("c '".. aoespell .."'")
        Note("Casting AoE spell: " .. aoespell)
      else
        Note("No AoE spell selected.")
      end
    </send>
  </alias>

  <!-- Set the atkspell -->
  <alias
   match="aam set atk (.*)"
   enabled="y"
   group="attack"
   send_to="12"
   sequence="100"
   regexp="y"
  >
    <send>atkspell = "%1"
      SetVariable("atkspell", "%1")
      Note("Set the attack spell to: " .. atkspell)
    </send>
  </alias>

  <!-- Set the aoespell -->
  <alias
   match="aam set aoe (.*)"
   enabled="y"
   group="attack"
   send_to="12"
   sequence="100"
   regexp="y"
  >
    <send>aoespell = "%1"
      SetVariable("aoespell", "%1")
      Note("Set the AoE spell to: " .. aoespell)
    </send>
  </alias>

<!-- Clear primary attack or AoE or skill or all -->
<alias
   match="aam clear (patk|aoe|skill|shortsyntax|all)"
   enabled="y"
   group="attack"
   send_to="12"
   sequence="100"
   expand_variables="y"
   regexp="y"
>
    <send>
      local target = "%1"
      if target == "patk" then
        -- Clear all primary attack spells
        Patk = {}
        SetVariable("Patk", "Patk = {}")
        Note("Cleared all primary attack spells.")
      elseif target == "aoe" then
        -- Clear all AoE spells
        Aoe = {}
        SetVariable("Aoe", "Aoe = {}")
        Note("Cleared all AoE spells.")
      elseif target == "skill" then
        -- Clear all skills
        Skills = {}
        SetVariable("Skills", "Skills = {}")
        Note("Cleared all skills.")
	  elseif target == "shortsyntax" then
	    -- Clear all Short syntax
		SkillShortSyntax = {}
		SetVariable("SkillShortSyntax", "SkillShortSyntax = {}")
		Note("Cleared all Short syntax.")
      else
        -- Clear both primary attack, AoE spells, and skills
        Patk = {}
        Aoe = {}
        Skills = {}
        SetVariable("Patk", "Patk = {}")
        SetVariable("Aoe", "Aoe = {}")
        SetVariable("Skills", "Skills = {}")
        Note("Cleared all primary attack spells, AoE spells, and skills.")
      end
    </send>
</alias>

  
  <!-- New aliases for skills -->
  
  <!-- Set the skill -->
<alias
   match="aam set skill (.*)"
   enabled="y"
   group="attack"
   send_to="12"
   sequence="100"
   regexp="y"
>
  <send>
    skill = "%1"
    SetVariable("skill", "%1")
    Note("Set the primary skill to: " .. skill)
  </send>
</alias>

  
  <!-- Add Skill -->
<alias
   match="aam add skill (.*)"
   enabled="y"
   group="attack"
   send_to="12"
   sequence="100"
   expand_variables="y"
   regexp="y"
  >
    <send>local skill = "%1"
      -- Add skill to the Skills table (case-insensitive check for existing skill)
      local found = false
      for _, v in ipairs(Skills) do
        if string.lower(v) == string.lower(skill) then
          found = true
          break
        end
      end
      if not found then
        table.insert(Skills, skill)
        Note("Added skill: " .. skill)
      else
        Note("Skill already exists in the list.")
      end
    </send>
  </alias>

<!-- Remove Skill -->
<alias
   match="aam rem skill (.*)"
   enabled="y"
   group="attack"
   send_to="12"
   sequence="100"
   expand_variables="y"
   regexp="y"
  >
    <send>
      local skill = "%1"
      -- Find the index of the skill in the Skills table (case-insensitive)
      local index = nil
      for i, v in ipairs(Skills) do
        if string.lower(v) == string.lower(skill) then
          index = i
          break
        end
      end
      -- Remove skill if found
      if index then
        table.remove(Skills, index)
        Note("Removed skill: " .. skill)
      else
        Note("Skill not found in the list.")
      end
    </send>
  </alias>
  
<!-- Cast Skill -->
<alias
   match="aam skill"
   enabled="y"
   group="attack"
   send_to="12"
   sequence="100"
>
    <send>-- Get variable
	skill = GetVariable("skill")
    -- Check if the skill has a short syntax set
    local shortSkill = SkillShortSyntax[string.lower(skill)]
    if shortSkill then
        skill = shortSkill  -- Use the short syntax
    end
    -- Cast the skill
    if skill then
        Send(skill)
        Note("Casting skill: " .. skill)
    else
        Note("No skill selected.")
    end
    </send>
</alias>


<!-- Cast Skill with Target -->

<alias
   match="aam skill *"
   enabled="y"
   group="attack"
   send_to="12"
   sequence="100"
>
    <send>-- Get variable
	skill = GetVariable("skill")
    -- Check if the skill has a short syntax set
    local shortSkill = SkillShortSyntax[string.lower(skill)]
    if shortSkill then
        skill = shortSkill  -- Use the short syntax
    end
    local mobname = "%1"
    -- Cast the skill
    if skill then
        Send(skill .." ".. mobname)
        Note("Casting skill: " .. skill)
    else
        Note("No skill selected.")
    end
    </send>
</alias>


<!-- Set the skill short syntax -->
<alias
   match="aam setskill (.*) to (.*)"
   enabled="y"
   group="attack"
   send_to="12"
   sequence="100"
   regexp="y"
>
  <send>
    local skill = "%1"
    local shortSyntax = "%2"
    -- Store the short syntax for the skill
    SkillShortSyntax[string.lower(skill)] = string.lower(shortSyntax)
    Note("Set the short syntax for skill '" .. skill .. "' to: " .. shortSyntax)
  </send>
</alias>

<!-- Show the short syntax for a skill -->
<alias
   match="aam showskill (.*)"
   enabled="y"
   group="attack"
   send_to="12"
   sequence="100"
   regexp="y"
>
  <send>
    local skill = "%1"
    local shortSyntax = SkillShortSyntax[string.lower(skill)]
    if shortSyntax then
        Note("The short syntax for skill '" .. skill .. "' is: " .. shortSyntax)
    else
        Note("No short syntax set for skill '" .. skill .. "'")
    end
  </send>
</alias>


</aliases>

<!-- Script -->
<script>
<![CDATA[

require "serialize"

-- Initialize the tables for storing attack and AoE spells
Patk = {}
Aoe = {}
Skills = {}
SkillShortSyntax = {}

-- Function to check if a value exists in a table (case-insensitive)
function table.contains(tbl, val)
  for _, v in ipairs(tbl) do
    if string.lower(v) == string.lower(val) then
      return true
    end
  end
  return false
end

-- Help function to explain how the plugin works
function OnHelp()
  Note("")
  Note("Keeps your Aoe, Atk or Skill variables updated automatically based on what is added to the lists for each.")
  Note("They will be set to the variables automatically as you level or when u remort and practice the first time.")
  Note("As long as its practiced to 85% or 95% it will be updated for aoe, atk, or skill based on your lists.")
  Note("")
  Note("aam add patk/aoe/skill [spell or skill] - Add a primary attack, skill, or aoe spell to the list.")
  Note("")
  Note("aam rem patk/aoe/skill [spell or skill] - Remove a primary attack, skill, or aoe spell from the list.")
  Note("")
  Note("aam list patk/aoe/skill/shortsyntax/all - List spells from patk, aoe, skill, shortsyntax, or all.")
  Note("")
  Note("aam clear patk/aoe/skill/shortsyntax/all - Clear list from patk, aoe, skill, shortsyntax, or all.")
  Note("")
  Note("aam set atk/aoe/skill [spell or skill] - Set the atk, skill, or aoe spell.")
  Note("")
  Note("aam atk - Casts the spell set for atk.")
  Note("")
  Note("aam atk [mobname] - Casts the spell set for atk at the target input.")
  Note("")
  Note("aam skill - Uses current set skill.")
  Note("")
  Note("aam skill [mobname] - Uses current set skill on target.")
  Note("")
  Note("aam setskill [skillname] to [shortsyntax] - Sets the shortsyntax to use when using the skill")
  Note("                                           Example: aam setskill Cobra Bane to cobra or aam setskill cobra bane to cobra")
  Note("")
  Note("aam showskill [skillname] - Will show the shortsyntax set for the given skill.")
  Note("")
  Note("aam aoe - Casts the spell set for aoe.")
  Note("")
  Note("aam update check - Checks for a update.")
  Note("")
  Note("aam update install - Installs the update.")
  Note("")
end

-- Save the stored tables and reload them on new session
function OnPluginSaveState ()
  -- Save both spellsTable and currentIndex
  SetVariable("Patk", "Patk = " .. serialize.save_simple(Patk))
  SetVariable("Aoe", "Aoe = " .. serialize.save_simple(Aoe))
  SetVariable("Skills", "Skills = " .. serialize.save_simple(Skills))
  SetVariable("SkillShortSyntax", "SkillShortSyntax = " .. serialize.save_simple(SkillShortSyntax))
end

function OnPluginInstall ()
  ColourNote("blue", "yellow", "Plugin Installed! Type aam help - to show help")
  assert(loadstring(GetVariable("Patk") or ""))()
  assert(loadstring(GetVariable("Aoe") or ""))()
  assert(loadstring(GetVariable("Skills") or ""))()
  assert(loadstring(GetVariable("SkillShortSyntax") or ""))()
end

 ----------------------- Plugin Update Code -----------------------
 -- Code taken from Durel's dinv plugin, originally via Crowley
 require("wait")
require("async")
json = require("json")

 plugin_url = "https://raw.githubusercontent.com/Khrysis-aard/plugins/refs/heads/main/Atk_Aoe_Manager.xml"
 SetVariable("DownloadURL", plugin_url)
 plugin_protocol = "HTTPS"
 plugin_prefix = "[Atk_Aoe_Manager]"
 
 function update_check_alias()
     update_plugin("check")
     ColourNote("yellow", "", plugin_prefix .. "","white",""," Checking for updated version...")
 end
 
 function update_install_alias()
     update_plugin("install")
     ColourNote("yellow", "", plugin_prefix .. "","white",""," Checking for and installing updated version...")
 end
 
 function reload_plugin()
     local scriptPrefix = GetAlphaOption("script_prefix")
     local retval
 
     -- If the user has not already specified the script prefix for this version of mush, pick a
     -- reasonable default value
     if (scriptPrefix == "") then
         scriptPrefix = "\\\\\\"
         SetAlphaOption("script_prefix", scriptPrefix)
     end
 
     -- Tell mush to reload the plugin in one second.  We can't do it directly here because a
     -- plugin can't unload itself.  Even if it could, how could it tell mush to load it again
     -- if it weren't installed? 
     retval = Execute(scriptPrefix.."DoAfterSpecial(0.1, \"ReloadPlugin('"..GetPluginID().."')\", sendto.script)")
 end
 
 function update_plugin(mode)
     update_mode = mode
 
     wait.make(get_plugin_file)
 end
 
 function get_plugin_file()
     local urlThread = async.request(plugin_url, plugin_protocol)
 
     if not urlThread then
         note_error("Couldn't create async url request.")
         return
     end
 
     local timeout = 10
     local totTime = 0
     while (urlThread:alive() and totTime < timeout) do
         wait.time(0.1)
         totTime = totTime + 0.1
     end
 
     local remoteRet, pluginData, status, headers, fullStatus = urlThread:join()
 
     if not status then
         ColourNote("red", "", plugin_prefix .. " Couldn't download plugin file. No status code.")
         
         return
     end
 
     if (status ~= 200) then
         ColourNote("red", "", plugin_prefix .. " Plugin file request status code: " .. status .. ": " .. fullStatus)
         return
     end
     
     local currentVersion = GetPluginInfo(GetPluginID(), 19) or 0
     local currentVerStr  = string.format("%1.3f", currentVersion)
     local remoteVerStr   = string.match(pluginData, '%s%s+version="([0-9%.]+)"')
     local remoteVersion  = tonumber(remoteVerStr or "") or 0
 
     if remoteVersion == currentVersion then
         ColourNote("yellow", "", plugin_prefix .. "","white",""," You are running the most recent version. (","cyan","","v" .. currentVerStr .. "","white","",")")
     elseif (remoteVersion < currentVersion) then
         ColourNote("yellow", "", plugin_prefix .. "","white",""," You have a newer version than is publicly available. (","cyan","","v" .. currentVerStr .. "","white","",")")
     elseif (update_mode == "check") then
         ColourNote("yellow", "", plugin_prefix .. "","white",""," You are running ","cyan","","v" .. currentVerStr .. "","white",""," , but there's a newer version ","cyan","","v" .. remoteVerStr)
     elseif (update_mode == "install") then
         ColourNote("yellow", "", plugin_prefix .. "","white",""," Updating plugin from version ","cyan","", currentVerStr .. "","white",""," to version ","cyan","", remoteVerStr .."") 
 
         local pluginFile = GetPluginInfo(GetPluginID(), 6)
         local file = io.open(pluginFile, "wb")
         file:write(pluginData)
         file:close()
         reload_plugin()
     else
         ColourNote("red", "", plugin_prefix .. " Invalid update mode: " .. update_mode)
     end
 end
 ----------------------- End Plugin Update Code -----------------------
]]>
</script>

</muclient>
